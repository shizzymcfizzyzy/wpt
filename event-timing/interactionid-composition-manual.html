<!doctype html>
<html>

<head>
    <style>
        table,
        td {
            padding: 8px;
            border: 1px solid black;
        }
    </style>
</head>

<body>
    <title>Event Timing: interactionId composition events.</title>
    <form>
        <b> Select your Operating System from the list</b>
        <select id="option" onchange="dropdownMenu()">
            <option> ---Choose OS--- </option>
            <option> Linux </option>
            <option> Windows </option>
        </select>
        <p> Your selected OS is:
            <input type="text" id="os" size="20">
        </p>
    </form>
    <pre>
    Steps:
    1) Open <b id = "IMEtype"></b> IME and select Hiragana input method.
    2) Click at the above textbox and then type 'a' using keyboard.
    3) Press the '{Enter}' key to complete the IME composition.
    4) <a href="interactionid-composition-manual.html">Click here</a> to test again if not following the steps exactly.
</pre>
    <textarea id='test' placeholder="enter 'a'"></textarea>
    <table id="eventLogTable">
        <tr>
            <td>InteractionId</td>
            <td>Event Type</td>
            <td>Number of Events</td>
        </tr>
    </table>
    <script src="/resources/testharness.js"></script>
    <script src="/resources/testharnessreport.js"></script>
    <script src=resources/event-timing-test-utils.js></script>
    <script>
        setup({ explicit_timeout: true, explicit_done: true });

        function dropdownMenu() {
            var list = document.getElementById("option");
            document.getElementById("os").value = list.options[list.selectedIndex].text;
            if (document.getElementById("os").value == "Linux") {
                document.getElementById("IMEtype").textContent = "Japanese - Mozc";
            }
            else if (document.getElementById("os").value == "Windows") {
                document.getElementById("IMEtype").textContent = "Japanese Microsoft";
            }
        }

        function addEventType(interactionId, eventType, nrOfEvents) {

            var table = document.getElementById("eventLogTable");
            var row = table.insertRow();

            // Add values to the table
            var cell = row.insertCell();
            cell.innerHTML = interactionId;
            cell = row.insertCell();
            cell.innerHTML = eventType;
            cell = row.insertCell();
            cell.innerHTML = nrOfEvents;
        }

        let observedEntries = [];
        let map = new Map();
        const events = ['keydown', 'keypress', 'keyup', 'compositionupdate', 'compositionstart', 'compositionend'];


        function eventsForCheck(entry) {
            if (entry.name === 'compositionupdate' || entry.name === 'keydown' || entry.name === 'input' || entry.name === 'keyup'
                || entry.name === 'compositionstart' || entry.name === 'compositionend') {
                if (map.has(entry.name)) {
                    map.get(entry.name).push(entry.interactionId);
                    return true;
                }
                else {
                    map.set(entry.name, [entry.interactionId]);
                    return true;
                }
            }

            return false;
        }

        test(function () {
            assert_implements(window.PerformanceEventTiming, 'Event Timing is not supported.');
            new PerformanceObserver(entryList => {
                observedEntries = observedEntries.concat(entryList.getEntries().filter(eventsForCheck));

                if (!observedEntries.find(entry => entry.name === "compositionend"))
                    return;

                // Create a Set to track seen values
                const seenInteractionIds = new Set();

                // Check for duplicates within the array
                let hasDuplicates = false;
                for (const value of map.get("input")) {
                    if (seenInteractionIds.has(value)) {
                        hasDuplicates = true;
                        assert_false(hasDuplicates, "All Inputs shall have unique InteractionIds.");
                        break;
                    }
                    seenInteractionIds.add(value);
                }
                assert_equals(map.get("input").length, map.get("compositionupdate").length, "For every input there should be exactly one compositionupdate");
                assert_equals(map.get('compositionstart')[0], 0, 'Compositionstart should not have an interactionId');
                addEventType(map.get('compositionstart')[0], "compositionstart", 1);

                map.get("input").forEach(value => {
                    assert_greater_than(value, 0, 'Input should have an interactionId greater than 0');
                    const filteredArrayKeydowns = map.get('keydown').filter(interactionId => interactionId === value);
                    const countKeydowns = filteredArrayKeydowns.length;
                    addEventType(value, "keydown", countKeydowns);
                    assert_true((countKeydowns <= 1), "For each input there should be no more than 1 keydown. There might be exceptions due to current bug in counts in ChromeOS: TODO(crbug.com/1252856).");

                    addEventType(value, "compositionupdate", 1);
                    addEventType(value, "input", 1);

                    const filteredArrayKeyups = map.get('keyup').filter(interactionId => interactionId === value);
                    const countKeyups = filteredArrayKeyups.length;
                    addEventType(value, "keyup", countKeyups);
                    assert_true((countKeyups >= 0 && countKeyups < 5), "Each keydown should have no more than 4 keyups");

                });
                assert_equals(map.get('compositionend')[0], 0, 'Compositionend should not have an interactionId');
                addEventType(map.get('compositionstart')[0], "compositionend", 1);
                done();
                observedEntries = [];
            }).observe({ type: "event" });

            addListeners(document.getElementById('test'), events);
        });

    </script>
</body>

</html>